'================================= Intro ==================================
' CR1000X Series Datalogger
' Single Beam Range Finder
' Aaron Kehl
' USACE-ERDC-CRREL
' April 2020
'
' NAL 9602-N ISBD Modem
' C3      - white wire (TX Datalogger, RX Device)
' C4      - green wire (RX Datalogger, TX Device)
' C5      - Red wire, PWR
' G       - black wires
'
' G-NSDOG2-003 Inclinomter (measures +-90 degrees)
' SW12V_1 - red wire
' G       - black wire
' SE1     - green wire (X axis measurement)
' SE2     - white wire (Y axis measurement)
'
' Trusense S200 Range Finder
' C1      - Blue (TX Datalogger, RX Device)
' C2      - Brown (RX Datalogger, TX Device)
' SW12V-1 - Pink
' G       - Black
'
' Troll 700H Pressure Transducer
' SW12V_1 - Red (8-36VDC)
' C7      - White (SDI-12)
' G       - Black (G), Blue (RS-485+), & Green (RS-485-) (all must be GND)
'============================= End of Intro ===============================

'================================ Setup ===================================
'-------------------------- Global Variables ------------------------------
'System Variables for Public tracking
Public sysStatus As String * 100
Public iridStatus As String * 100
Public laserStatus As String * 100
Public inclinStatus As String * 100
Public pressStatus As String * 250
Public ISBD_Message_BIN As String * 300
Public ISBD_Message_HEX As String * 300
Public ISBD_Message_ASCII As String * 500

'Campbell System Variables
Public forceRead, forceMessage, PTemp As Float, batt_volt As Float
Const measInterval = 15        'Time interval to take measurements [min]
Const sendInterval = 60        'Time interval to send ISBD messages [min]
Const OpenDate = 91            '01 = Jan 1, 91 = April 1
Const CloseDate = 304          '366 = Dec 31, 304 = Oct 31
Public rTime(9)                'declare as public and dimension rTime to 9
Alias rTime(1) = Year          'assign the alias Year to rTime(1)
Alias rTime(2) = Month         'assign the alias Month to rTime(2)
Alias rTime(3) = DOM           'assign the alias DOM to rTime(3)
Alias rTime(4) = Hour          'assign the alias Hour to rTime(4)
Alias rTime(5) = Minute        'assign the alias Minute to rTime(5)
Alias rTime(6) = Second        'assign the alias Second to rTime(6)
Alias rTime(7) = uSecond       'assign the alias uSecond to rTime(7)
Alias rTime(8) = WeekDay       'assign the alias WeekDay to rTime(8)
Alias rTime(9) = Day_of_Year   'assign the alias Day_of_Year to rTime(9)

'Iridium Variables
Const Iridiumport = ComC3      'Datalogger's control ports C3 (TX) & C4 (RX)
Const Iridiumpowerport = C5    'Power control switch port, used as 0V or 5V
Const numvals = 10             'Number of variables packed into an ISBD Msg
Const BYTES_1 = 1              'Used to clarify ISBD Message Readability
Const BYTES_2 = 2              '                   ""
Const BYTES_4 = 4              '                   ""
Public msgSuccess = 1          'Helps to decide if messages should be retried

'Trusense S200 Range Finder Variables
Const Laserport = ComC1        'Datalogger's control ports C1 (TX) & C2 (RX)
Const nWarmup = 20             'number of warmup readings before recording
Const nLaserSamples = 50       'number of samples per reading, after warmup
Public raw_first( nLaserSamples ) As Float
Public raw_strongest( nLaserSamples ) As Float
Public raw_last( nLaserSamples ) As Float
Public first As Float, last As Float, strongest As Float

'Inclinometer Variables
Const xPort = 1
Const yPort = 2
Const nAngleSamples = 50
Public raw_x( nAngleSamples ) As Float, raw_y( nAngleSamples ) As Float
Public x As Float, y As Float

'TROLL 700H Pressure Transducer Variables
Const pressPort = C7           ' The SDI-12 Data Port Pin#
Const nPressSamples = 10       ' Number of repeated readings
Const pressAddr = 0            ' The device address on SDI-12
Public raw_pressPress( nPressSamples ) As Float
Public raw_pressTemp( nPressSamples ) As Float
Public raw_pressLevel( nPressSamples ) As Float
Public pressPress As Float     ' Storage variable for averaged pressure
Public pressTemp As Float      ' Storage variable for averaged temps of prb
Public pressLevel As Float     ' Storage variable for averaged level of prb
'------------------------- End of Global Variables ------------------------

'------------------------------ Data Tables -------------------------------
' Update processed sensor data into stored memory, note this is also the
' structure for ISBD messages, formed via lastrecord().
DataTable( hourtab, 1, -1 )
  CardOut( 0, -1 )
  Minimum( 1, batt_volt, FP2, 0, 0 )
  Sample( 1, PTemp, FP2 )
  Sample( 1, first, IEEE4 )
  Sample( 1, strongest, IEEE4 )
  Sample( 1, last, IEEE4 )
  Sample( 1, x, IEEE4 )
  Sample( 1, y, IEEE4 )
  Sample( 1, pressPress, IEEE4 )
  Sample( 1, pressTemp, IEEE4 )
  Sample( 1, pressLevel, IEEE4 )
EndTable

' Write raw measurements into memory.
DataTable( rawMeasurements, 1, -1 )
  CardOut( 0, -1 )
  Sample( nLaserSamples, raw_first, IEEE4 )
  Sample( nLaserSamples, raw_strongest, IEEE4 )
  Sample( nLaserSamples, raw_last, IEEE4 )
  Sample( nAngleSamples, raw_x, IEEE4 )
  Sample( nAngleSamples, raw_y, IEEE4 )
  Sample( nPressSamples, raw_pressPress, IEEE4 )
  Sample( nPressSamples, raw_pressTemp, IEEE4 )
  Sample( nPressSamples, raw_pressLevel, IEEE4 )
EndTable
'-------------------------- End of Data Tables ----------------------------
'============================ End of Setup ================================

'========================== Helper Subroutines ============================
'------------------------- toLong( Float, INT ) ---------------------------
' This Function converts a Float to a Long Integer, using the number of
' decimal places to determine how to convert.  This is for ISBD Messages.
'
' e.g. 1234.123 has 3 decimal places, so the long version returned by this
'   function would be 1234123
'
' INPUTS: floatval = the float value to be converted
'    decimalPlaces = the number of decimal places in the float value
' OUTPUTS: Long integer version of the float value.
'
'    ** Note: Requires post processing to return to a float value. **
'
Function toLong( floatval As Float, decimalPlaces )
  Dim multiplier, result As Long, i
  multiplier = 1

  Select Case decimalPlaces
    Case 1 To 4
      For i = 1 To decimalPlaces Step 1
        multiplier *= 10
      Next i
    Case Else
      multiplier = 1
  EndSelect

  result = FIX( floatval * multiplier )
  Return( result )
End Function
'---------------------- End of toLong( Float, INT ) -----------------------

'------------------------- dblPow( float, float ) -------------------------
' This function returns a double value number.  The "^" or PWR function Only
' can return a float value, which is overloaded to NAN when using the 8 byte
' number during time-syncing via ISBD
'
' INPUTS: base = the base number in floating point format
'     exponent = the power that the base will be raised to.
' OUTPUT: result = A double precision floating point number
'
Function dblPow( base As Float, exponent As Float)
  Dim i, result As Double
  result = base

  For i = 2 to exponent Step 1
    result *= base
  Next i

  Return( result )
End Function
'---------------------------- End of dblPow() -----------------------------

'-------------------------- toDecimal( String ) ---------------------------
' This function takes in a hexadecimal string and converts it to a decimal.
' The build in HexToDec() function interprets the value as two's complement,
' so sometimes an epoch will be decoded as (-) using the built in function.
'
' This function will not interpret the hexadecimal string as two's comp.
'
' INPUTS: hex_value = Hexadecimal string (frames since epoch, generally)
' OUTPUTS: decmial_value = decimal representation of hex number
'
Function toDecimal( hex_value as String )
  'Declare variables local to this function, only initializes 1x on startup.
  Dim val As String, bytes, decimal_pos, decimal_value As Double, i

  'reset variables to initial value, every time this function is called.
  bytes = Len( Trim( hex_value ) )
  decimal_value = 0.0
  decimal_pos = bytes - 1

  For i = 1 to bytes Step 1
    val = Mid( hex_value, i, 1 )

    Select Case val
      Case 1
        decimal_value += 1 * dblPow( 16, decimal_pos )
      Case 2
        decimal_value += 2 * dblPow( 16, decimal_pos )
      Case 3
        decimal_value += 3 * dblPow( 16, decimal_pos )
      Case 4
        decimal_value += 4 * dblPow( 16, decimal_pos )
      Case 5
        decimal_value += 5 * dblPow( 16, decimal_pos )
      Case 6
        decimal_value += 6 * dblPow( 16, decimal_pos )
      Case 7
        decimal_value += 7 * dblPow( 16, decimal_pos )
      Case 8
        decimal_value += 8 * dblPow( 16, decimal_pos )
      Case 9
        decimal_value += 9 * dblPow( 16, decimal_pos )
      Case "A", "a"
        decimal_value += 10 * dblPow( 16, decimal_pos )
      Case "B", "b"
        decimal_value += 11 * dblPow( 16, decimal_pos )
      Case "C", "c"
        decimal_value += 12 * dblPow( 16, decimal_pos )
      Case "D", "d"
        decimal_value += 13 * dblPow( 16, decimal_pos )
      Case "E", "e"
        decimal_value += 14 * dblPow( 16, decimal_pos )
      Case "F", "f"
        decimal_value += 15 * dblPow( 16, decimal_pos )
      Case Else
        decimal_value += 0
    EndSelect

    decimal_pos -= 1
  Next i

  return( decimal_value )
End Function
'------------------------- End of toDecimal() -----------------------------

'--------------------------- isLeapYear( INT ) ----------------------------
' This function will determine whether it is a leap year or not.
'
' INPUTS: year_in_question = integer representation of the year to be eval.
' OUTPUTS: 0 = Not a leapyear
'          1 = A leapyear
Function isLeapYear( year_in_question )
  'Determine whether it is a leap year or not
  If year_in_question MOD 4 = 0 Then
    If year_in_question MOD 400 = 0 OR year_in_question MOD 100 <> 0 Then
      Return 1
    Else
      Return 0
    EndIf
  Else
    Return 0
  EndIf
End Function
'------------------------ End of isLeapYear( INT ) ------------------------

'----------------------- updateTimestamp( String ) ------------------------
' This function will convert an Ascii hexadecimal string containing
' 90ms intervals from iridium epoch, into UTC to assist with updating
' the system time clock of the Campbell Datalogger.
'
' INPUTS: val = hexidecimal string 90ms intervals from epoch.
' OUTPUTS: N/A
'
'        ** epoch: May 11, 2014, at 14:23:55 **
'
' Jan: 31, Feb: 28(or 29), Mar: 31, Apr: 30, May: 31, Jun: 30
' Jul: 31, Aug: 31, Sep: 30, Oct: 31, Nov: 30, Dec: 31
Sub updateTimestamp( val As String )
  Dim clockValues(7), frames_since_epoch As Double
  Dim days_in_year, utcDOY As Long, utcYear As Long, found
  Dim daysInMonths(12), utcDOM As Long, utcMOY As Long, index
  Dim utcHour As Float, utcMinute As Float, utcSecond As Float
  Dim utcUSecond As Float, count

  'Process the number of 90ms frames from the epoch into 1s frames
  frames_since_epoch = toDecimal( val )
  frames_since_epoch = frames_since_epoch * 0.09

  'Calculate time of day from 90ms frames
  utcHour = ( ( frames_since_epoch MOD 86400 ) / 86400 ) * 24
  utcMinute = ( ( frames_since_epoch MOD 3600 ) / 3600 ) * 60
  utcSecond = frames_since_epoch MOD 60
  utcUSecond = ( frames_since_epoch * 1000000 ) MOD 1000000

  'correct the values for the epoch start time
  utcSecond += 55
  If utcSecond >= 60 Then
    utcMinute += 1
    utcSecond -= 60
  EndIf
  utcMinute += 23
  If utcMinute >= 60 Then
    utcHour += 1
    utcMinute -= 60
  EndIf
  utcHour += 14
  If utcHour >= 24 Then utcHour -= 24

  '////////////////////// Find Year and Day of Year ///////////////////////
  'Subtract remaining days in 2014 (from epoch)
  'Begin the find year process in the year 2015
  ' epoch start is day 131.6 of year, leaving 233.4 days left in year 2014
  utcDOY = Floor( ( frames_since_epoch / 86400 ) - 233.40005787 )
  utcYear = 2015
  found = 0
  count = 0

  'Find the Year and Day of Year.
  ' loops through the years and subtracts the number of days of that
  ' calendar year from the days since the epoch (adjusted to 2015)
  ' until it tries to go negative.  Then the current year has been found
  While found = 0 AND count < 1000
    'Update days in the year based on which year we are evaluating
    If isLeapYear( utcYear ) Then
      days_in_year = 366
    Else
      days_in_year = 365
    EndIf

    'Evaluate whether to increment 1 year or not
    If utcDOY - days_in_year <= 0 Then
      found = 1
    Else
      utcDOY -= days_in_year
      utcYear += 1
    EndIf

    count += 1
  Wend
  '/////////////////// End of Find Year and Day of Year ///////////////////

  '////////////////// Find Month of Year and Day of Month /////////////////
  'Generate an array with the number of days in each month
  For index = 1 To 12 Step 1
    Select Case index
      Case 1, 3, 5, 7, 8, 10, 12
        daysInMonths( index ) = 31
      Case 4, 6, 9, 11
        daysInMonths( index ) = 30
      Case 2
        If isLeapYear( utcYear ) Then
          daysInMonths( index ) = 29
        Else
          daysInMonths( index ) = 28
        EndIf
    EndSelect
  Next index

  'reset variables. Dim declares one time at initialization
  'and does not overwrite on each function call.
  found = 0
  index = 1
  utcDOM = utcDOY

  ' find and return the day of the month by subtracting 1 month
  ' of days at a time, from the number passed into this function
  While found = 0 AND index <= 12
    If utcDOM - daysInMonths( index ) <= 0 Then
      utcMOY = index
      found = 1
    Else
      utcDOM -= daysInMonths( index )
      index += 1
    EndIf
  Wend
  '///////////// End of Find Month of Year and Day of Month //////////////

  'prepare the variable to write to the clock
  clockValues(1) = utcYear       '[year]
  clockValues(2) = utcMOY        '[month] of year
  clockValues(3) = utcDOM        '[day] of Month
  clockValues(4) = Floor( utcHour )     '[hr] of day
  clockValues(5) = Floor( utcMinute )   '[min] of hour
  clockValues(6) = Floor( utcSecond )   '[s] of min
  clockValues(7) = Floor( utcUSecond )  '[us] of second

  'Update the system clock with the UTC timestamp from the ISBD satellite
  ClockSet( clockValues() )
EndSub
'-------------------- End of updateTimestamp( String ) --------------------
'======================= End of Helper Subroutines ========================

'=========================== Iridium Functions ============================
'----------------------------- closeIridium() -----------------------------
' Close the iridium com port and turn-off the modem.
'
' INPUTS: N/A
' OUTPUTS: 0 = Failed to close port
'          1 = Closed the port to the modem
'
Function closeIridium()
  SerialOut( Iridiumport, "AT+SBDD0" + CHR(13), "", 0, 100 )
  SerialFlush( Iridiumport )
  If SerialClose( Iridiumport ) <> 0 Then
    'iridStatus = "Iridium port closed, and modem powered off."
    PortSet( Iridiumpowerport, 0 )
    Return 1  'True
  Else
    'iridStatus = "Could not close port, but modem powered off."
    PortSet( Iridiumpowerport, 0 )
    Return 0  'False
  EndIf
End Function
'-------------------------- End of closeIridium() -------------------------

'------------------------------ openIridium() -----------------------------
' Open the iridium com port and turn-on the modem.
'
' INPUTS: N/A
' OUTPUTS: 0 = Failed to open the port to the modem.
'          1 = Opened the port to the modem.
'
Function openIridium()
  PortSet( Iridiumpowerport, 1 )
  Delay( 1, 3, Sec )
  If SerialOpen( Iridiumport, 19200, 3, 0, 200 ) Then
    iridStatus = "1) Iridium port open, and modem powered on."
    Return 1  'True
  Else
    closeIridium()
    iridStatus = "1) Iridium port failed to open and has been powered off."
    Return 0  'False
  EndIf
End Function
'---------------------------- End of openIridium() ------------------------

'---------------------------- modemReady( String ) ------------------------
' Ensure the ISBD modem is ready for message tranmission
'
' INPUTS: message = ISBD message for transmission, fully constructed
' OUTPUTS: 0 = Modem is not ready
'          1 = Modem is ready
'
Function modemReady( mesLength As Long)
  Dim outStr As String * 20, waitStr As String = "READY"
  outStr = ( "AT+SBDWB=" & mesLength & CHR(13) )
  If SerialOut( Iridiumport, outStr, waitStr, 1, 300 ) <> 0 Then
    iridStatus = ( "2) Modem is ready." )
    Return 1  'True
  Else
    iridStatus = ( "2) Modem is not ready." )
    Return 0  'False
  EndIf
End Function
'------------------------ End of modemReady( String ) ---------------------

'----------------------------- messageAccepted() --------------------------
' Check to see if the modem has accepted the data message
'
' INPUTS: N/A
' OUTPUTS: 0 = Modem did not accept the message.
'          1 = Modem accepted the message.
'
Function messageAccepted()
  Dim binaryok As String * 5
  SerialIn( binaryok, Iridiumport, 100, "0", 5 )
  SplitStr( binaryok, binaryok, "", 1, 0 )

  Select Case binaryok
    Case "0"
      iridStatus = "3) Modem accepted the message."
      Return 1  'True
    Case "1"
      iridStatus = "3) Modem failed to accept message, length too small."
      Return 0  'False
    Case "2"
      iridStatus = "3) Modem failed to accept message, checksum does not match."
      Return 0  'False
    Case "3"
      iridStatus = "3) Modem failed to accept message, length too large."
      Return 0  'False
    Case Else
      iridStatus = "3) Modem failed to accept message, uknown error."
      Return 0  'False
  EndSelect

End Function
'------------------------- End of messageAccepted() -----------------------

'----------------------------- satConnected() -----------------------------
' Set modem config and wait for satellite connection
'
' INPUTS:  N/A
' OUTPUTS: 0 = Could not connect to a satellite.
'          1 = Connected to a satellite.
'
Function satConnected()
  Dim outStr As String = ( "AT+CIER=1,0,1,0" & CHR(13) )
  Dim waitStr As String = "+CIEV:1,1"
  If SerialOut( Iridiumport, outStr, waitStr, 1, 1000 ) <> 0 Then
    iridStatus = "4) Connected to satellite."
    Return 1  'True
  Else
    iridStatus = "4) Could not connect to a satellite."
    Return 0  'False
  EndIf
End Function
'-------------------------- End of SatConnected() -------------------------

'----------------------------- satReceived() ------------------------------
' Checks to see if message was successfully transmitted to a satelite
'
' INPUTS:  N/A
' OUTPUTS:  0 = Satellite has not received message.
'           1 = Satellite has received message.
'
Function satReceived()
  Dim messageresult As String * 50, numresult(2) As String * 50
  Dim result(6)

  SerialOut( Iridiumport, "AT+SBDIX" & CHR(13), "", 0, 0 )
  SerialIn( messageresult, Iridiumport, 4000, 0, 30 )

  SplitStr( numresult, messageresult, ":", 2, 5 )
  SplitStr( result, numresult(2), ",", 6, 5 )

  If ( result( 1 ) < 5 ) Then
    iridStatus = "5) The satellite has receieved the message."
    Return 1  'True
  Else
    iridStatus = "5) The satellite was not able to receieve the message."
    Return 0  'False
  EndIf
End Function
'---------------------------- End of satReceived() ------------------------

'------------------------------ syncTimestamp() ---------------------------
' Sync system time with satelite time, via ISBD. Due to the complexity
' of days of the month, given a particular year, only the time of day
' will be updated by the time sync. That is, Hour, minute, second, usecond.
' Year, month, day, will still be assigned by the campbell system, based
' on user input.
'
' Iridium time system epoch is May 11, 2014, 14:23:55 (GMT).
'
' INPUTS:   N/A
' OUTPUTS:  0 if Unsuccessful
'           1 if Successful
'
Function syncTimestamp()
  '-MSSTM to obtain satelite time, not +CCLK to obtain modem system time.
  Dim outStr As String = ( "AT-MSSTM" & CHR(13) )
  Dim response As String * 100, count
  count = 0

  If SerialOut( Iridiumport, outStr, "", 5, 100 ) <> 0 Then
    SerialIn( response, Iridiumport, 500, 0, 29 )

    ' Try to sync the time up to 5x, if it has no network.
    While( InStr( 1, response, "no network", 2 ) <> 0 AND count <= 4 )

      If  SerialOut( Iridiumport, outStr, "", 5, 100 ) <> 0 Then
        SerialIn( response, Iridiumport, 500, 0, 29 )
      EndIf

      Delay( 0, 3, 2 )
      count += 1
    Wend

    ' If the response still says no network, we cannot sync the time right now.
    ' Otherwise, extract the frames since epoch from the response string.
    If InStr( 1, response, "no network", 2 ) = 0 Then
      SplitStr( response, response, ":", 1, 8 )
      updateTimestamp( response )
      iridStatus = "Successfully synced system time of day with satellite."
      Return 1   'True
    Else
      iridStatus = "Unable to sync system time of day with satellite."
      Return 0   'False
    EndIf

  Else
    iridStatus = "Unable to sync system time of day with satellite."
    Return 0     'False
  EndIf
End Function
'--------------------------- End of syncTimestamp() -----------------------

'-------------------------- constructMessage( int ) -----------------------
' Construct the message contents for transmission via ISBD
'
' Note: the variable that contains the binary message must be public in
' order for the campbell to be able to transmit to the modem.
'
' INPUTS:   nValues, number of unique variables to be packet in the message
' OUTPUTS:  The length of the constructed ISBD Message ready for transmission
'
' Message Composition:
'Po---Variable--------Units--------Data----Multiplier---------Example-----
'01.    Date      |  YYYYMMDD  | 4 Bytes |     1      |      20200611
'02.    Time      |   HHMMSS   | 4 Bytes |     1      |       140453
'03.  Battery     |   Volts    | 2 Bytes |    100     |   12.14 -> 1214
'04. Panel Temp   |  'Celsius  | 2 Bytes |    100     |   17.24 -> 1724
'05.   First      |   Meters   | 4 Bytes |   1000     | 203.555 -> 203555
'06. Strongest    |   Meters   | 4 Bytes |   1000     | 258.745 -> 258745
'07.    Last      |   Meters   | 4 Bytes |   1000     | 103.756 -> 103756
'08.     X        |   Degrees  | 4 Bytes |   1000     |   1.035 -> 1035
'09.     Y        |   Degrees  | 4 Bytes |   1000     | -14.035 -> -14035
'10.  Pressure    |    kPa     | 4 Bytes |   1000     | 101.325 -> 101325
'11.    Temp      |  'Celsius  | 4 Bytes |   1000     |   8.375 -> 8375
'12.   Level      |     cm     | 4 Bytes |   1000     |  43.844 -> 43844
'13.  checksum    |    N/A     | 2 Bytes |     1      | *Only sent to Modem*
'
'     ** All values are transmitted as 2's complement binary integers **
'  ** And must be post-processed to include decimal places ( e.g. /100 ) **
Function constructMessage()
  Dim lastrecord(numvals), YYYYMMDD As Long, HHMMSS As Long
  Dim longValue As Long, holder As Long, offset, i
  Dim iridchecksum As Long, tstamp(6) As Long

  iridStatus = "Constructing message for ISBD transmission..."

  'reset values each time this function is called (dim only initializes 1x)
  ISBD_Message_BIN = ""
  ISBD_Message_ASCII = ""
  offset = 0

  'Get the last data recorded
  GetRecord( lastrecord, hourtab, 1 )

  'Generate timestamp for data included in the message.
  SplitStr( tstamp, hourtab.TimeStamp( 6, 1 ), "_-.", 6, 7 )
  YYYYMMDD = ( ( tstamp(1) * 100 + tstamp(2) ) * 100 + tstamp(3) )
  HHMMSS = ( ( tstamp(4) * 100 + tstamp(5) ) * 100 + tstamp(6) )

  'Insert date, into message
  ISBD_Message_ASCII = YYYYMMDD
  MoveBytes( ISBD_Message_BIN, offset, YYYYMMDD, 0, BYTES_4 )
  offset += BYTES_4

  'Insert time, into message
  MoveBytes( ISBD_Message_BIN, offset, HHMMSS, 0, BYTES_4 )
  ISBD_Message_ASCII &= ", " & HHMMSS
  offset += BYTES_4

  'Insert minimum battery voltage into message
  longValue = toLong( lastrecord(1), 2 )
  MoveBytes( ISBD_Message_BIN, offset, longValue, 2, BYTES_2 )
  ISBD_Message_ASCII &= ", " & longValue
  offset += BYTES_2

  'Insert panel temp into message
  longValue = toLong( lastrecord(2), 2 )
  MoveBytes( ISBD_Message_BIN, offset, longValue, 2, BYTES_2 )
  ISBD_Message_ASCII &= ", " & longValue
  offset += BYTES_2

  'Insert first laser reading value into message
  longValue = toLong( lastrecord(3), 3 )
  MoveBytes( ISBD_Message_BIN, offset, longValue, 0, BYTES_4 )
  ISBD_Message_ASCII &= ", " & longValue
  offset += BYTES_4

  'Insert strongest laser reading value into message
  longValue = toLong( lastrecord(4), 3 )
  MoveBytes( ISBD_Message_BIN, offset, longValue, 0, BYTES_4 )
  ISBD_Message_ASCII &= ", " & longValue
  offset += BYTES_4

  'Insert last laser reading value into message
  longValue = toLong( lastrecord(5), 3 )
  MoveBytes( ISBD_Message_BIN, offset, longValue, 0, BYTES_4  )
  ISBD_Message_ASCII &= ", " & longValue
  offset += BYTES_4

  'Insert x angle value into message
  longValue = toLong( lastrecord(6), 3 )
  MoveBytes( ISBD_Message_BIN, offset, longValue, 0, BYTES_4 )
  ISBD_Message_ASCII &= ", " & longValue
  offset += BYTES_4

  'Insert y angle value into message
  longValue = toLong( lastrecord(7), 3 )
  MoveBytes( ISBD_Message_BIN, offset, longValue, 0, BYTES_4 )
  ISBD_Message_ASCII &= ", " & longValue
  offset += BYTES_4

  'Insert pressure reading value from pressure transducer into message
  longValue = toLong( lastrecord(8), 3 )
  MoveBytes( ISBD_Message_BIN, offset, longValue, 0, BYTES_4 )
  ISBD_Message_ASCII &= ", " & longValue
  offset += BYTES_4

  'Insert temperature reading value from pressure transducer into message
  longValue = toLong( lastrecord(9), 3 )
  MoveBytes( ISBD_Message_BIN, offset, longValue, 0, BYTES_4 )
  ISBD_Message_ASCII &= ", " & longValue
  offset += BYTES_4

  'Insert level reading value from pressure transducer into message
  longValue = toLong( lastrecord(10), 3 )
  MoveBytes( ISBD_Message_BIN, offset, longValue, 0, BYTES_4 )
  ISBD_Message_ASCII &= ", " & longValue
  offset += BYTES_4

  'Append checksum to binary message
  iridchecksum = CheckSum( ISBD_Message_BIN, 23, offset )
  MoveBytes( ISBD_Message_BIN, offset, iridchecksum, 2, BYTES_2 )
  ISBD_Message_ASCII &= ", " & iridchecksum
  offset += 2

  'Convert ISBD binary message into a readable hex
  ISBD_Message_HEX = ""
  For i = 1 To offset Step 1
    holder = 0
    MoveBytes( holder, 3, ISBD_Message_BIN, i - 1, BYTES_1 )
    ISBD_Message_HEX &= Hex( holder ) & " "
  Next i

  Return( offset )
End Function
'----------------------- End of constructMessage( int ) -------------------

'------------------------------ sendMessage() -----------------------------
' Handles the overall process for sending an ISBD message via the 9602 - N
'
' INPUTS:   N/A
' OUTPUTS:  0 if Unsuccessful
'           1 if Successful
'
Function sendMessage()
  Dim attempts, success, length
  attempts = 0
  success = 0
  length = constructMessage()

  openIridium()
  syncTimestamp()

  While ( ( success <> 1 ) AND ( attempts < 4 ) )
    If modemReady( length - 2 ) Then
      'send the message data to the ISBD modem
      SerialOutBlock( Iridiumport, ISBD_Message_BIN, length )
      If messageAccepted() Then
        If satConnected() Then
          If satReceived() Then
            iridStatus = ( "Successfully sent an ISBD message: "  & Month & "/" & DOM & "-" & Hour & ":" & Minute )
            success = 1  'True
          ElseIf attempts = 4 Then
            iridStatus = "Unable to send ISBD message."
            success = 0  'False
          EndIf
        EndIf
      EndIf
    EndIf

    If success = 0 Then
      attempts += 1
      iridStatus = ( "Unable to send message: " & Month & "/" & DOM & "-" & Hour & ":" & Minute & ", tries: " & attempts )
    EndIf
  Wend

  'return the modem to its inactive state.
  closeIridium()
  Return success
End Function
'-------------------------- End of sendMessage() --------------------------
'======================== End of Iridium Functions ========================

'**************************************************************************
'******************************* SENSORS **********************************
'**************************************************************************
'======================= Trusense S200 Functions ==========================
'--------------------------- cmdS200( String ) ----------------------------
' Condenses the calls required to communicate with the range finder.
'
' INPUTS: String command for Trusense S200
' OUTPUTS: Device response or Error String
'
Function cmdS200( cmd As String )
  Dim CRLF As String = (CHR(13) & CHR(10)), response As String * 100
  SerialFlush( Laserport )
  laserStatus = ( "Sending: " & cmd & CRLF )

  If SerialOut( Laserport, cmd & CRLF, "", 0, 0 ) <> 0 Then
    'laserStatus = ( cmd & CRLF & " sent to laser." )
    SerialIn( response, Laserport, 100, 10, 100 )
    laserStatus = ( "Response: " & response )
    Delay( 0, 1, 2 )
    Return( response )
  Else
    laserStatus = ( "Failed to send command to laser." )
  EndIf
End Function
'----------------------- End of cmdS200( String ) -------------------------

'----------------------------- closeS200() --------------------------------
' Closes the comm port for the range finder and updates laser status.
Sub closeS200()
  SerialClose( Laserport )
  laserStatus = ( Laserport & " has been closed." )
EndSub
'-------------------------- End of closeS200() ----------------------------

'----------------------------- openS200() ---------------------------------
' Opens/initializes the comms port to the Truesense S200 Range Finder.
'
' INPUTS:  N/A
' OUTPUTS:  0 = Failed to open the port to the s200.
'           1 = Comms are open to the s200.
'
Function openS200 As Boolean
  Dim nTries
  nTries = 0
  openS200 = 0

  'Make 4 attempts to open the serial port
  While ( openS200 = 0 AND nTries < 4 )
    'Default Values:
    '      Baud Rate: 115200, Parity = None, Data Bits = 8
    '      Stop Bits = 1, Flow Control: None
    If SerialOpen( Laserport, 115200, 0, 0, 200 ) <> 0 Then
      laserStatus = ( Laserport & " successfully opened, num tries: " & nTries )
      openS200 = 1  'True
    Else
      nTries += 1
      laserStatus = ( Laserport & " not opened." & "attempt: " & nTries )
      closeS200()
      openS200 = 0 'False
    EndIf
  Wend

End Function
'-------------------------- End of openS200() -----------------------------

'----------------------------- initS200() ---------------------------------
' This subroutine makes sure the S200 is always set to our preferences.
' Initialization function for the Trusense S200. Parameters can be
' modified, but keep in mind that the program Is set up For default
' settings of the following:
'      1. Measurement units: Meters.
'      2. Right digits: 3.
'      3. Warmup readings: 20 (altered in global variables above).
'      4. Measurement Mode: Standard.
'      5. Long Range Scan Mode: Always report weaker.
'      6. Target Mode: First, Strongest, Last.
'
' INPUTS:  N/A
' OUTPUTS: 0  = Unsuccessful intilialization
'          1  = Successfully initialized
'
Function initS200()
  If openS200() Then
    laserStatus = "Initializing the Trusense S200."

    ' Set Units AND Right digits
    '    "$MU,u,d"
    '        u: M = meter
    '           F = Feet
    '           Y = Yards
    '           N = Nautical Mile (1852m)
    '        d: 0-3 = Number of decimal points displayed
    laserStatus = "Setting units and number of right digits..."
    cmdS200( "$MU,M,3" )
    laserStatus = "Rebooting..."
    Delay( 0, 5, 2 )  'Wait for hardware reboot

    ' Set the number of warmup readings
    '    "$WU,n"
    '        n: 0 = disabled
    '           1-99 = warmup readings, discarded before meas.
    laserStatus = "Setting the number of warmup readings..."
    cmdS200( "$WU," & nWarmup )

    ' Set the measurement mode
    '    "$MM,n"
    '        n: 0 = Standard (Ref: 750m, NRef: 750m)
    '           1 = Extended (Ref: 1500m, NRef: 900m)
    '           2 = Intelligent (Ref: 2900m, NRef: 1600m)
    '           4 = 200Hz
    laserStatus = "Setting the measurement mode..."
    cmdS200( "$MM,0" )

    ' Set the Long range Scan mode
    '    "$LS,n"
    '        n: 0 = Do NOT report weaker targets
    '           1 = Report weaker If no strong
    '           2 = Always report weaker
    laserStatus = "Setting the long range scan mode..."
    cmdS200( "$LS,2" )

    ' Set the target mode
    '    "$DM,n"
    '        n: 2 = First target
    '           3 = Strongest target
    '           4 = Last target
    '           5 = First, second, third targets
    '           6 = Last 2 (farthest AND second farthest) targets
    '           7 = First, strongest, last targets
    '           8 = First, second, third, strongest, last targets
    laserStatus = "Setting the target mode..."
    cmdS200( "$DM,7" )

    ' Write these settings into non-volatile memory
    laserStatus = "Writing to non volatile memory..."
    cmdS200( "$SU" )

    laserStatus = "Successfully initialized the Trusense S200."
    closeS200()
    laserStatus = "Off."
    Return 1  'True
  Else
    laserStatus = "Failed to initialize the Trusense S200."
    closeS200()
    laserStatus = "Off."
    Return 0  'False
  EndIf
End Function
'-------------------------- End of initS200() -----------------------------

'----------------------------- sampleS200() -------------------------------
' This function is responsible for obtaining sampling measurements from
' the Trusense S200 range finder. After issuing the start command, the
' function will sleep Until there Is input waiting from the S200.  Upon
' which, 3 lists are populated from the response strings of the S200.  An
' example of comms to/from the laser AND the datalogger is as follows:
'
'   To S200: $GO,m,n (m Is NOT required, but can be used)
'     - Take n readings at m frequency, after discarding warmup readings
'   To datalogger: $OK,crc
'     - response confirmation
'   To datalogger:
'     - Measurement reporting. # of responses = # of readings
'     - Example: $DM,A,3.08,3.08,3.08,M,0,853.851*B056
'
Sub sampleS200()
  Dim i, count, response As String * 100, splitResponse(7) As String * 100

  If openS200() Then
    ' Send the start command to the range finder
    cmdS200( "$GO," & nLaserSamples )

    ' Give the S200 a moment to process your request
    count = 0
    While( SerialInChk( Laserport ) = 0 AND count < 1000 )
      'Do nothing, continue to wait until a max of timeout for activity
      Delay( 0, 10, 1 )  'delay for 10[ms], up to a total of 10s
      count += 1
    Wend

    ' Read in the raw results from the S200
    For i = 1 To nLaserSamples Step 1
      SerialIn( response, Laserport, 100, 10, 100 )
      laserStatus = ( "Response(" & i & ")" & " : " & response )
      SplitStr( splitResponse, response, ",", 7, 7 )

      If StrComp( splitResponse(1), "$DM" ) = 0 AND StrComp( splitResponse(2), "A" ) = 0 Then
        ' Data is good, assign it to respective variables
        raw_first(i) = splitResponse(3)
        raw_strongest(i) = splitResponse(4)
        raw_last(i) = splitResponse(5)
      Else
        ' Data is not good, assign respective error values
        raw_first(i) = -999
        raw_strongest(i) = -999
        raw_last(i) = -999
      EndIf

      'A small delay to make sure the next data is available
      count = 0
      While( i < nLaserSamples AND SerialInChk( Laserport ) = 0 AND count < 300 )
        'Do nothing, continue to wait until a max of timeout for activity
        Delay( 0, 10, 1 )  'delay for 10[ms], up to a total of 3s
        count += 1
      Wend

    Next i
  Else
    laserStatus = "Invalid response from laser."
  EndIf

  closeS200()
EndSub
'-------------------------- End of sampleS200()----------------------------

'----------------------------- processS200() ------------------------------
' Proccesses the raw data for first, strongest, and last values taken
' by the Trusense S200 range finder.  Bad values are filtered out
' and currently this subroutine just averages the good data points and
' updates the global variables.
Sub processS200()
  Dim sum, nGoodVals, i

  ' Average the first values based on good readings, ignores bad.
  nGoodVals = nLaserSamples
  sum = 0
  For i = 1 To nLaserSamples Step 1
    Select Case raw_first(i)
      Case Is > 0 AND < 999999
        sum += raw_first(i)
      Case Else
        nGoodVals -= 1
    EndSelect
  Next i
  If nGoodVals = 0 Then first = -999 Else first = ( sum / nGoodVals )

  ' Average the strongest values based on good readings, ignores bad.
  nGoodVals = nLaserSamples
  sum = 0
  For i = 1 To nLaserSamples Step 1
    Select Case raw_strongest(i)
      Case Is > 0 AND < 999999
        sum += raw_strongest(i)
      Case Else
        nGoodVals -= 1
    EndSelect
  Next i
  If nGoodVals = 0 Then strongest = -999 Else strongest = ( sum / nGoodVals )

  ' Average the last values based on good readings, ignores bad.
  nGoodVals = nLaserSamples
  sum = 0
  For i = 1 To nLaserSamples Step 1
    Select Case raw_last(i)
      Case Is > 0 AND < 999999
        sum += raw_last(i)
      Case Else
        nGoodVals -= 1
    EndSelect
  Next i
  If nGoodVals = 0 Then last = -999 Else last = ( sum / nGoodVals )

EndSub
'------------------------- End of processS200() ---------------------------

'--------------------------- measRangeFinder() ----------------------------
' Simplifies call to measure the Trusense range finder and process the
' results.  Keeps the mainProg calls simple and consistent.
Sub measRangeFinder()
  laserStatus = "Measuring..."
  sampleS200()
  processS200()
  laserStatus = "Off."
EndSub
'------------------------ End of measRangeFinder() ------------------------
'==================== End of Trusense S200 Functions ======================

'========================= TROLL 700H Functions ===========================
'------------------- addrPressureTransducer( String ) ---------------------
' Change the SDI-12 Address for the pressure transducer.
' No error checking so this function assumes assignment worked.
' Returns the information of the device at the new address to confirm that
' the new address works with comms. Should be called manually when a
' change of address is required.
' Note: Update pressAddr constant value once address has been changed.
'
' INPUTS:  oldAddr = if there are multiple devices specify which addr
'                    ess you want to update.
'          newAddr = what you want to change the old address to.
'
'  *** Make sure to update pressAddr in the global variables above ***
'  *** It is not done here, in order to force the user to re-upload ***
'
' OUPTUPS: response = returns the SDI12 response from the new address
'                     with the device info to confirm update by user.
'
Function addrPressureTransducer( oldAddr, newAddr )
  Dim response As String * 25
  Dim cmd As String * 5
  cmd = ( "A" & newAddr & "!" )
  pressStatus = "Updating the SDI_12 address..."
  SDI12Recorder( response, pressPort, oldAddr, cmd, 1.0, 0, -1, 1 )
  SDI12Recorder( response, pressPort, newAddr, "I!", 1.0, 0, -1, 1 )
  pressStatus = ( "Response: " & response )
  Return response
End Function
'----------------- End of addrPressureTransducer( String ) ----------------

'------------------------ findPressureTransducer() ------------------------
' Initially will report all devices on the SDI12 bus... Then will process
' responses to obtain which device is the pressure transducer.
' Function should be called manually when necessary.  Values will be
' reported to the public datatable for viewing inside LoggerNet
Sub findPressureTransducer()
  Dim addresses(5) As String * 25, i, found
  Dim sensorsInfo(5) As String * 25
  found = 0

  pressStatus = "Obtaining SDI12 addresses..."
  SDI12Recorder( addresses, pressPort, 0, "?!", 1.0, 0, -1, 1 )
  pressStatus = ( "Response: " & addresses )

  'Store information responses, for up to 10 sensors
  pressStatus = ""
  For i = 1 To 5 Step 1
    SDI12Recorder( sensorsInfo(i), pressPort, addresses(i), "I!", 1.0, 0, 0 )
    If InStr( 1, sensorsInfo(i), "SITU LT700", 2 ) <> 0 Then
      pressStatus += ( addresses(i) & ": " & sensorsInfo(i) & "," )
      found += 1
    EndIf
  Next i

  If found = 0 Then pressStatus = "No SDI devices found."
EndSub
'--------------------- End of findPressureTransducer() --------------------

'------------------------ initPressureTransducer() ------------------------
' Makes sure the TROLL 700H is set to our preferences whenever the
' datalogger initializes (i.e. reboot, restart, power loss, etc...)
Sub initPressureTransducer()
  Dim response As String * 25

  ' Set the units for pressure
  ' Sends:   XPUnn!
  '             nn = 17; PSI
  '                = 19; Kpa
  '                = 20; bar
  '                = 21; mbar
  '                = 22; mmHg
  '                = 23; inHg
  '                = 24; cmH2O
  '                = 25; inH2O
  SDI12Recorder( response, pressPort, pressAddr, "XPU19!", 1, 0, 0 )
  SDI12Recorder( response, pressPort, pressAddr, "D0!", 1, 0, 0 )
  pressStatus = ( "Set units for Pressure, response: " & response )

  ' Set the units for Temperature
  ' Sends:  XTUnn!
  '            nn = 01; 'C
  '            nn = 02; 'F
  SDI12Recorder( response, pressPort, pressAddr, "XTU01!", 1, 0, 0 )
  SDI12Recorder( response, pressPort, pressAddr, "D0!", 1, 0, 0 )
  pressStatus = ( "Set units for Temperature, response: " & response )

  ' Set the units for level
  ' Sends: XLUnn!
  '           nn = 33; mm
  '              = 34; cm
  '              = 35; m
  '              = 37; in
  '              = 38; ft
  SDI12Recorder( response, pressPort, pressAddr, "XLU34!", 1, 0, 0 )
  SDI12Recorder( response, pressPort, pressAddr, "D0!", 1, 0, 0 )
  pressStatus = ( "Set units for level, response: " & response )

  ' Set the reporting mode for the level value
  ' Sends: XLMnn!
  '           nn = 03; depth
  '              = 04; level from top of casing
  '              = 05; level in elevation
  SDI12Recorder( response, pressPort, pressAddr, "XLM03!", 1, 0, 0 )
  SDI12Recorder( response, pressPort, pressAddr, "D0!", 1, 0, 0 )
  pressStatus = ( "Set mode for level, response: " & response )

  ' Set the output types and sequence
  ' Sends: XOnnn!
  '          nnn = 1 to 3 characters in the required output order
  '          characters: P = Pressure, T = Temperature, L = Level
  SDI12Recorder( response, pressPort, pressAddr, "XOPTL!", 1, 0, 0 )
  SDI12Recorder( response, pressPort, pressAddr, "D0!", 1, 0, 0, 0 )
  pressStatus = ( "Set output types/sequence, reponse: " & response )

  pressStatus = ( "Troll 700H has been initialized." )
  pressStatus = ( "Off." )
EndSub
'--------------------- End of initPressureTransducer() --------------------

'------------------------ calibPressureTransducer() -----------------------
' This subroutine will set the calibration values/references for the Troll
' 700H Pressure Transducer.  This won't be reperformed on startup/reboot.
' Call manually when initial setup is needed...
Sub calibPressureTransducer()
  Dim response As String * 25

  ' Set the specific gravity of the medium
  ' Sends: XSGpd.d!
  '            p = polarity sign ( + or - )
  '            d = 1 to 7 digits ( 0 - 9 )
  '            . = decimal point ( optional )
  SDI12Recorder( response, pressPort, pressAddr, "XSG+1.0!", 1, 0, 0 )
  Delay( 0, 1100 , 1 )
  SDI12Recorder( response, pressPort, pressAddr, "D0!", 1, 0, 0, 0 )
  pressStatus = ( "Set the specific gravity, reponse: " & response )

  ' Set the zero pressure state.
  ' Sends: XPZ!
  SDI12Recorder( response, pressPort, pressAddr, "XPZ!", 1, 0, 0 )
  Delay( 0, 1100, 1 )
  SDI12Recorder( response, pressPort, pressAddr, "D0!", 1, 0, 0, 0 )
  pressStatus = ( "Pressure zeroed, reponse: " & response )

  ' Set the level reference value in current units.
  ' Sends XLRpd.d!
  '            p = polarity sign ( + or - )
  '            d = digits ( 1 to 7 )
  '            . = decimal point ( optional )
  SDI12Recorder( response, pressPort, pressAddr, "XLR+0.0!", 1, 0, 0 )
  Delay( 0, 1100, 1 )
  SDI12Recorder( response, pressPort, pressAddr, "D0!", 1, 0, 0, 0 )
  pressStatus = ( "Level reference set, reponse: " & response )

  pressStatus = ( "Troll 700H has been calibrated." )
  pressStatus = ( "Off." )
EndSub
'-------------------- End of calibPressureTransducer() --------------------

'------------------------ procPressureTransducer() ------------------------
' Processes raw measurement data from the Pressure Transducer.  Currently
' this subroutine just averages the good values reported to the datalogger.
Sub procPressureTransducer()
  Dim i, sum As Float, nGoodVals

  'Average the pressure readings from the Troll 700H
  sum = 0
  nGoodVals = nPressSamples
  For i = 1 To nPressSamples Step 1
    Select Case raw_pressPress(i)
      Case Is > -10000000 AND < 10000000  ' In between -10 MPa and 10 MPa
        sum += raw_pressPress(i)
      Case Else
        nGoodVals -= 1
    EndSelect
  Next i

  ' Assign final values to the pressPress variable
  If nGoodVals = 0 Then
    pressPress = -999
  Else
    pressPress = sum / nGoodVals
  EndIf

  'Average the temperature readings from the Troll 700H
  sum = 0
  nGoodVals = nPressSamples
  For i = 1 To nPressSamples Step 1
    Select Case raw_pressTemp(i)
      Case Is > -100 AND < 100  ' In between -100'C and 100'C
        sum += raw_pressTemp(i)
      Case Else
        nGoodVals -= 1
    EndSelect
  Next i

  ' Assign final values to the pressPress variable
  If nGoodVals = 0 Then
    pressTemp = -999
  Else
    pressTemp = sum / nGoodVals
  EndIf

  'Average the level readings from the Troll 700H
  sum = 0
  nGoodVals = nPressSamples
  For i = 1 To nPressSamples Step 1
    Select Case raw_pressLevel(i)
      Case Is > -100000 AND < 100000  ' In between -100000 cm and 100000 cm
        sum += raw_pressLevel(i)
      Case Else
        nGoodVals -= 1
    EndSelect
  Next i

  ' Assign final values to the pressPress variable
  If nGoodVals = 0 Then
    pressLevel = -999
  Else
    pressLevel = sum / nGoodVals
  EndIf

EndSub
'--------------------- End of procPressureTransducer() --------------------

'------------------------ measPressureTransducer() ------------------------
' Sample the pressure transducer for pressure, temperature, and level for
' nPressSamples repetitions. Sends a measure command, then sends a read data
' command.  The transdcuer will report results in < 1s for each reading so
' this task could be time consuming if nPressSamples is large.
Sub measPressureTransducer()
  Dim i, response(3) As String * 25
  pressStatus = "Measuring..."

  ' Send pairs of measure/read commands to the SDI Sensor
  For i = 1 To nPressSamples Step 1
    SDI12Recorder( response, pressPort, pressAddr, "M!", 1, 0, -1 )
    SDI12Recorder( response, pressPort, pressAddr, "D!", 1, 0, -1 )
    pressStatus = ( "Response(" & i & "): " & response )
    raw_pressPress(i) = response(1)
    raw_pressTemp(i) = response(2)
    raw_pressLevel(i) = response(3)
  Next i

  pressStatus = ( "Processing..." )
  procPressureTransducer()
  pressStatus = ( "Off." )
EndSub
'--------------------- End of measPressureTransucer() ---------------------
'====================== End of TROLL 700H Functions =======================

'======================== Inclinometer Functions ==========================
'-------------------------- procInclinometer() ----------------------------
' Subroutine responsible for processing the analog mV data returned from
' the inclinometer.  This function will simply average the good data values
' and if there are no good data values then an error code will be assigned
' to the global variable for what was suppossed to be the average value.
Sub procInclinometer()
  Dim sum As Float, nGoodVals, i

  ' Average the good x angle values
  nGoodVals = nAngleSamples
  sum = 0
  For i = 1 To nAngleSamples Step 1
    Select Case raw_x(i)
      Case Is > 500 AND < 4500
        sum += raw_x(i)
      Case Else
        nGoodVals -= 1
    EndSelect
  Next i

  'Assign final values for the x angle
  If nGoodVals = 0 Then
    ' No good values were recorded
    x = -999
  Else
    ' Scale the milliVolt reading to the corresponding degree value
    ' mV range 500mv - 4500mV, 500mv = 90 degrees, 4500mV = -90 degrees
    x = ( ( ( sum / nGoodVals ) - 2500 ) / 2000 ) * -90
  EndIf

  ' Average the good y angle values
  nGoodVals = nAngleSamples
  sum = 0
  For i = 1 To nAngleSamples Step 1
    Select Case raw_y(i)
      Case Is > 500 AND < 4500
        sum += raw_y(i)
      Case Else
        nGoodVals -= 1
    EndSelect
  Next i

  ' Assign final values to the y angle
  If nGoodVals = 0 Then
    ' No good values were recorded
    y = -999
  Else
    ' Scale the milliVolt reading to the corresponding degree value
    ' mV range 500mv - 4500mV, 500mv = 90 degrees, 4500mV = -90 degrees
    y = ( ( ( sum / nGoodVals ) - 2500 ) / 2000 ) * -90
  EndIf

EndSub
'----------------------- End of procInclinometer() ------------------------

'-------------------------- measInclinometer() ----------------------------
' Takes analog measurements related to x and y angles.  Will convert mV
' into the appropriate degree angle via processing.
Sub measInclinometer()

  ' Acquire nAngleSamples signals for the x angle.
  inclinStatus = "Obtaining x angle values."
  VoltSe( raw_x, nAngleSamples, mV5000, -xPort, 1, 0, 250, 1.0, 0 )

  ' Acquire nAngleSamples signals for the y angle.
  inclinStatus = "Obtaining y angle values."
  VoltSe( raw_y, nAngleSamples, mV5000, -yPort, 1, 0, 250, 1.0, 0 )

  ' Average the good data acquired from the sensor
  inclinStatus = "Process angle measurements."
  procInclinometer()

  inclinStatus = "Off."
EndSub
'----------------------- End of measInclinometer() ------------------------
'==================== End of Inclinometer Functions =======================
'**************************************************************************
'**************************** End of SENSORS ******************************
'**************************************************************************

'============================ Main Functions ==============================
'----------------------------- initSensors() ------------------------------
' Call to initialize all neccessary sensors on startup or reboot of the
' datalogger.  This makes sure that if any settings were stored in flash
' memory for a sensor, the sensors will retain our preferences by being
' itialized.
Sub initSensors()
  SW12( SW12_1, 1 )  ' Turn on the peripheral sensors
  Delay( 0, 2, 2 )   ' Let the sensors warm up
  initS200()         ' Initialize the Truesense S200
  initPressureTransducer()  ' Initialize the Troll 700H
  SW12( SW12_1, 0 )  ' Return the peripheral sensors to their default state.
EndSub
'-------------------------- End of initSensors() --------------------------

'----------------------------- measSensors() ------------------------------
' Compiles all sensor measurement calls to keep main prog simple/concise.
Sub measSensors()
  sysStatus = "Recording panel temp and battery voltage..."
  PanelTemp( PTemp, 250 )  ' Get/store panel temperature
  Battery( batt_volt )     ' Get/store battery voltage

  sysStatus = "Powering/warming up peripheral sensors..."
  SW12( SW12_1, 1 )
  Delay( 0, 2, 2 )

  sysStatus = "Getting range finder data..."
  measRangeFinder()

  sysStatus = "Getting pressure trandsucer data..."
  measPressureTransducer()

  sysStatus = "Getting angles of inclination..."
  measInclinometer()

  'Return the peripheral sensors To their default state.
  SW12( SW12_1, 0 )
EndSub
'------------------------- End of measSensors() ---------------------------

'----------------------------- Main Program -------------------------------
BeginProg
  'Place tasks her to perform on every single startup/reboot of the logger.
  sysStatus = "Completing on startup tasks."
  initSensors()
  openIridium()
  syncTimestamp()
  closeIridium()
  sysStatus = "On startup tasks completed."

  ' Troubleshooting or other one time use functions should be used here
  ' Uncomment/comment commands as needed. for example the pressure
  ' transducer should only be calibrated 1x on setup not on every startup.
  ' So make sure to recomment out commands after using them  and reupload
  ' or each will be performed on every startup of the datalogger.
  ' Examples:
  '  findPressureTransducer()    'You should update pressAddr constant as needed (global)
  '  addrPressureTransducer(0,2) 'Update pressAddr constant after changing sdi address
  '  calibPressureTransducer()   'Make sure settings are correct when doing this

  ' Check to see if measurements are to be conducted or messages sent.
  Scan( 1, min, 0, 0 )
    ' Update time in order to assess the day of the year.
    RealTime( rTime )

    ' Check to see if measurements are to be made
    If Day_of_Year <= CloseDate AND Day_of_Year >= OpenDate Then
      If TimeIntoInterval( 0, measInterval, min ) OR forceRead = 1 Then
        sysStatus = "Measuring sensors..."
        measSensors()
        sysStatus = "Updating DataTables to memory."
        CallTable rawMeasurements
        CallTable hourtab
        forceRead = 0            ' Return to default state
      EndIf

      ' Check to see if an ISBD message should be sent
      If TimeIntoInterval( 1, sendInterval, min ) OR forceMessage = 1 Then
        sysStatus = "Sending an ISBD message."
        msgSuccess = sendMessage()
        forceMessage = 0
      ElseIf TimeIntoInterval( 3, 5, min ) AND msgSuccess = 0 Then
        sysStatus = "Attempting to send the ISBD message again..."
        msgSuccess = sendMessage()
      EndIf

    EndIf
    sysStatus = "Standby..."
  NextScan

  SlowSequence
  ' Update system time with satellite (if possible)
  ' during non-measurement times of year. Should
  ' resolve the issue of not "waking up."
  Scan( 6, hr, 0, 0 )
    If Day_of_Year >= CloseDate AND Day_of_Year <= OpenDate Then
      sysStatus = "Sycning time with satellite..."
      openIridium()
      syncTimestamp()
      closeIridium()
    EndIf
    sysStatus = "Standby..."
  NextScan

EndProg
'------------------------- End of Main Program ----------------------------
'======================== End of Main Functions ===========================
